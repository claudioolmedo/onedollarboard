<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>One Dollar Board</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  
  
  <script>
    
    function generateProjectID() {
      
      function randomHex(len) {
        return Array.from({length: len}, () => Math.floor(Math.random() * 16).toString(16)).join('');
      }
      
      
      return `${randomHex(8)}-${randomHex(4)}-${randomHex(4)}-${randomHex(4)}-${randomHex(9)}`;
    }
    
    
    function getProjectIDFromURL() {
      
      const urlParams = new URLSearchParams(window.location.search);
      const projectIDFromQuery = urlParams.get('projectID');
      if (projectIDFromQuery) {
        return projectIDFromQuery;
      }
      
      
      const hash = window.location.hash.substring(1);
      if (hash) {
        
        if (hash.includes('projectID=')) {
          const hashParams = new URLSearchParams(hash);
          return hashParams.get('projectID');
        }
        
        return hash;
      }
      
      return null;
    }
    
    
    let projectID = getProjectIDFromURL();
    if (!projectID) {
      const newID = generateProjectID();
      const newURL = `${window.location.pathname}?projectID=${newID}`;
      
      window.location.replace(newURL);
      
    } else {
      
      window.PROJECT_CODE = projectID;
    }
  </script>
  
  <style>
    :root { 
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif; 
    }
    body { 
      margin: 0; 
      background: #0b0d10; 
      color: #e6edf3; 
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    .header {
      background: #11161b;
      border-bottom: 1px solid #202830;
      padding: 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }
    .project-name-container {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
      min-width: 0;
    }
    #projectNameDisplay {
      font-size: 1.2rem;
      font-weight: 600;
      color: #e6edf3;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: text;
      user-select: none;
      transition: background-color 0.2s, border-color 0.2s;
      border: 1px solid transparent;
      display: flex;
      align-items: center;
      gap: 8px;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      position: relative;
    }
    #projectNameDisplay:hover {
      background: #161b22;
      border-color: #30363d;
    }
    #projectNameDisplay:active {
      background: #0d1117;
    }
    #projectNameDisplay .edit-icon {
      opacity: 0;
      transition: opacity 0.2s;
      font-size: 0.85rem;
      color: #6e7681;
      flex-shrink: 0;
    }
    #projectNameDisplay:hover .edit-icon {
      opacity: 0.6;
    }
    #projectNameText {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex: 1;
      min-width: 0;
    }
    #projectNameInput {
      background: #0d1117;
      border: 1px solid #1f6feb;
      border-radius: 6px;
      padding: 8px 12px;
      color: #e6edf3;
      font-size: 1.2rem;
      font-weight: 600;
      font-family: inherit;
      min-width: 200px;
      max-width: 400px;
      outline: none;
      box-shadow: 0 0 0 3px rgba(31, 111, 235, 0.1);
    }
    #projectNameInput::placeholder {
      color: #6e7681;
      font-weight: normal;
    }
    h1 { 
      font-size: 1.2rem; 
      margin: 0;
      color: #e6edf3;
    }
    .controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    button {
      background: #1f6feb;
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 10px 14px;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
    }
    button:hover {
      background: #2a7de8;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    button.secondary {
      background: #30363d;
    }
    button.secondary:hover {
      background: #40464d;
    }
    button.compile {
      background: #238636;
    }
    button.compile:hover {
      background: #2ea043;
    }
    button.compile:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    button.download {
      background: #238636;
    }
    button.download:hover {
      background: #2ea043;
    }
    #status {
      font-size: 0.85rem;
      color: #9fbad1;
      padding: 8px 12px;
      background: #0d1117;
      border-radius: 6px;
      border: 1px solid #1f242e;
    }
    .status-connected {
      color: #3fb950;
      border-color: #238636;
    }
    .status-error {
      color: #ff7b72;
      border-color: #da3633;
    }
    .status-syncing {
      color: #d29922;
      border-color: #bb8009;
    }
    #syncIndicator {
      font-size: 0.75rem;
      padding: 6px 10px;
      background: #0d1117;
      border-radius: 6px;
      border: 1px solid #1f242e;
      min-width: 20px;
      text-align: center;
    }
    .sync-indicator-syncing {
      color: #d29922;
      animation: pulse 1.5s ease-in-out infinite;
    }
    .sync-indicator-synced {
      color: #3fb950;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    #connectionIcon {
      position: relative;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px;
    }
    #connectionIcon.connected {
      color: #3fb950;
    }
    #connectionIcon.disconnected {
      color: #ff7b72;
    }
    #connectionIcon .tooltip {
      visibility: hidden;
      opacity: 0;
      background-color: #161b22;
      color: #e6edf3;
      text-align: center;
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 0.75rem;
      position: absolute;
      z-index: 1000;
      bottom: 130%;
      left: 50%;
      transform: translateX(-50%);
      white-space: nowrap;
      border: 1px solid #30363d;
      transition: opacity 0.2s, visibility 0.2s;
      pointer-events: none;
    }
    #connectionIcon .tooltip::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 5px solid transparent;
      border-top-color: #161b22;
    }
    #connectionIcon:hover .tooltip {
      visibility: visible;
      opacity: 1;
    }
    #editor-container {
      flex: 1;
      position: relative;
      overflow: hidden;
    }
    #editor {
      width: 100%;
      height: 100%;
    }
    .footer {
      background: #11161b;
      border-top: 1px solid #202830;
      padding: 12px 16px;
      font-size: 0.85rem;
      color: #8093a7;
      flex-shrink: 0;
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="project-name-container">
      <div id="projectNameDisplay" title="Double-click to edit">
        <span id="projectNameText"></span>
        <span class="edit-icon">‚úèÔ∏è</span>
      </div>
      <input 
        type="text" 
        id="projectNameInput" 
        placeholder="Project Name" 
        maxlength="50"
        style="display: none;"
      />
    </div>
    <div class="controls">
      <button id="btnCompile" class="compile" disabled>üî® Compile</button>
      <button id="btnFlash" class="download" style="display: none;">üíæ Flash</button>
      <span id="status">Disconnected</span>
      <span id="connectionIcon" class="disconnected" title="">
        <span id="connectionIconSymbol">üî¥</span>
        <span class="tooltip" id="connectionTooltip">Offline</span>
      </span>
      <span id="syncIndicator" style="font-size: 0.75rem; color: #9fbad1;">‚è≥</span>
    </div>
  </div>
  
  <div id="editor-container">
    <div id="editor"></div>
  </div>

  <div class="footer">
    <b>One Dollar Board</b> - A low-cost mini computer main board for learning and prototyping.
  </div>

  
  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"></script>
  
  
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.5.0/firebase-app.js';
    import { getDatabase, ref, set, get, onValue } 
      from 'https://www.gstatic.com/firebasejs/12.5.0/firebase-database.js';

    
    const firebaseConfig = {
      apiKey: "AIzaSyBGp8r-Eir4NRnIRfeA6c6rIMZmdJnti4M",
      authDomain: "onedollarboard-1b26a.firebaseapp.com",
      databaseURL: "https://onedollarboard-1b26a-default-rtdb.firebaseio.com",
      projectId: "onedollarboard-1b26a",
      storageBucket: "onedollarboard-1b26a.firebasestorage.app",
      messagingSenderId: "448761452728",
      appId: "1:448761452728:web:f309f53f24cfbac5d8bc4d"
    };

    let app, database, codeRef;
    
    
    try {
      app = initializeApp(firebaseConfig);
      database = getDatabase(app);
      
      
      
    } catch (error) {
      console.error('‚ùå Error initializing Firebase:', error);
      alert('Error initializing Firebase. Check the console for details.');
    }

    
    const status = document.getElementById('status');
    const syncIndicator = document.getElementById('syncIndicator');
    const btnCompile = document.getElementById('btnCompile');
    const btnFlash = document.getElementById('btnFlash');
    const connectionIcon = document.getElementById('connectionIcon');
    const connectionIconSymbol = document.getElementById('connectionIconSymbol');
    const connectionTooltip = document.getElementById('connectionTooltip');

    let editor = null;
    let isSyncing = false;
    let isLocalChange = false; 
    let saveTimeout = null;
    let lastSavedContent = '';
    let isConnected = false; 
    let reconnectInterval = null;
    let isReconnecting = false;
    const DEBOUNCE_DELAY = 1000; 

    
    function showFlashButton(binary, size) {
      if (!btnFlash) {
        console.error('‚ùå btnFlash element not found!');
        return;
      }
      
      if (!binary) {
        console.error('‚ùå showFlashButton called without binary!');
        return;
      }
      
      btnFlash.style.display = 'block';
      btnFlash.style.visibility = 'visible';
      btnFlash.onclick = () => flashBinary(binary, size);
      
      btnFlash.offsetHeight;
      
      
      const computedStyle = window.getComputedStyle(btnFlash);
      const isVisible = computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden';
      
      console.log('‚úÖ showFlashButton function called');
      console.log('   - display:', btnFlash.style.display);
      console.log('   - visibility:', btnFlash.style.visibility);
      console.log('   - computed display:', computedStyle.display);
      console.log('   - computed visibility:', computedStyle.visibility);
      console.log('   - isVisible:', isVisible);
      console.log('   - binary size:', size, 'bytes');
      console.log('   - binary length:', binary ? binary.length : 0, 'chars');
      
      if (!isVisible) {
        console.error('‚ö†Ô∏è Button should be visible but computed style says otherwise!');
      }
    }

    
    function hideFlashButton() {
      btnFlash.style.display = 'none';
      btnFlash.onclick = null;
    }

    
    async function isBinaryValidForCode(data, currentContent, firebaseContent) {
      
      if (!data.binaryHash) {
        return false;
      }

      
      const currentHash = await getCodeHash(currentContent);
      
      
      if (currentHash !== data.binaryHash) {
        console.log('‚ö†Ô∏è Binary hash mismatch:');
        console.log(`   - Current code hash: ${currentHash}`);
        console.log(`   - Binary hash: ${data.binaryHash}`);
        return false;
      }

      
      const codeTimestamp = data.timestamp || (data.lastModified ? new Date(data.lastModified).getTime() : 0);
      const binaryTimestamp = data.binarySavedAt ? new Date(data.binarySavedAt).getTime() : 
                             (data.compilationUpdatedAt ? new Date(data.compilationUpdatedAt).getTime() : 0);

      
      if (!codeTimestamp || !binaryTimestamp) {
        console.warn('‚ö†Ô∏è Timestamps not available, using hash comparison only');
        return true; 
      }

      
      
      const isValid = binaryTimestamp >= (codeTimestamp - 1000);
      
      if (!isValid) {
        console.log('‚ö†Ô∏è Binary is not valid: compiled before last code modification');
        console.log(`   - Code modified: ${new Date(codeTimestamp).toISOString()}`);
        console.log(`   - Binary compiled: ${new Date(binaryTimestamp).toISOString()}`);
      }
      
      return isValid;
    }

    
    const DATABASE_URL = 'https://onedollarboard-1b26a-default-rtdb.firebaseio.com';
    
    
    const currentProjectCode = window.PROJECT_CODE;
    
    
    const DATABASE_PATH = `/projects/${currentProjectCode}`;
    
    
    let projectNameTimeout = null;
    async function saveProjectName(name) {
      if (!name || !name.trim()) {
        return;
      }
      
      try {
        const response = await fetch(`${DATABASE_URL}${DATABASE_PATH}/name.json`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name: name.trim(),
            updatedAt: new Date().toISOString(),
            timestamp: Date.now()
          })
        });
        
        if (response.ok) {
          console.log('‚úÖ Project name saved:', name.trim());
        } else {
          console.warn('‚ö†Ô∏è Failed to save project name');
        }
      } catch (error) {
        console.error('‚ùå Error saving project name:', error);
      }
    }
    
    
    function formatProjectNameDisplay(projectName) {
      if (projectName && projectName.trim()) {
        return `One Dollar Board/${projectName.trim()}`;
      }
      return 'One Dollar Board';
    }
    
    
    function extractProjectName(displayText) {
      if (displayText && displayText.includes('/')) {
        return displayText.split('/')[1] || '';
      }
      return displayText || '';
    }
    
    
    function updatePageTitle(projectName) {
      if (projectName && projectName.trim()) {
        document.title = `One Dollar Board/${projectName.trim()}`;
      } else {
        document.title = 'One Dollar Board';
      }
    }
    
    
    function updateProjectNameDisplay(projectName) {
      const projectNameText = document.getElementById('projectNameText');
      if (projectNameText) {
        projectNameText.textContent = formatProjectNameDisplay(projectName);
      }
      updatePageTitle(projectName);
    }
    
    
    async function loadProjectName() {
      try {
        const response = await fetch(`${DATABASE_URL}${DATABASE_PATH}/name.json`);
        if (response.ok) {
          const data = await response.json();
          if (data && data.name) {
            updateProjectNameDisplay(data.name);
            return data.name;
          }
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Error loading project name:', error);
      }
      
      updateProjectNameDisplay(null);
      return null;
    }
    
    
    function enterEditMode() {
      const display = document.getElementById('projectNameDisplay');
      const input = document.getElementById('projectNameInput');
      const text = document.getElementById('projectNameText');
      
      if (!display || !input || !text) return;
      
      
      const displayWidth = display.offsetWidth;
      
      
      display.style.display = 'none';
      input.style.display = 'block';
      input.style.width = displayWidth + 'px';
      
      
      const currentDisplay = text.textContent || '';
      const currentProjectName = extractProjectName(currentDisplay);
      input.value = currentProjectName === 'One Dollar Board' || !currentProjectName ? '' : currentProjectName;
      
      
      setTimeout(() => {
        input.focus();
        input.select();
      }, 10);
    }
    
    
    function exitEditMode(save = true) {
      const display = document.getElementById('projectNameDisplay');
      const input = document.getElementById('projectNameInput');
      const text = document.getElementById('projectNameText');
      
      if (!display || !input || !text) return;
      
      const newName = input.value.trim();
      
      if (save && newName) {
        
        updateProjectNameDisplay(newName);
        
        saveProjectName(newName);
      } else if (!newName) {
        
        const currentDisplay = text.textContent || '';
        const currentProjectName = extractProjectName(currentDisplay);
        if (currentProjectName === 'One Dollar Board' || !currentProjectName) {
          input.value = '';
        } else {
          input.value = currentProjectName;
        }
      }
      
      
      input.style.display = 'none';
      input.style.width = ''; 
      display.style.display = 'flex';
    }
    
    async function fetchBinaryFromCache(binaryHash) {
      if (!binaryHash) {
        return null;
      }
      
      try {
        const cacheResponse = await fetch(`${DATABASE_URL}/cache/${binaryHash}.json`);
        if (cacheResponse.ok) {
          const cacheData = await cacheResponse.json();
          if (cacheData && cacheData.binary) {
            return {
              binary: cacheData.binary,
              binarySize: cacheData.binarySize || 0
            };
          }
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Error fetching binary from cache:', error);
      }
      
      return null;
    }

    
    const VENDOR_ID = 0x1209;     
    const REPORT_ID = 0x00;       
    const CMD = { PING:0x01, INFO:0x02, ERASE64:0x10, LOAD64:0x11, PROG64:0x12, BOOT:0x20 };
    const DEFAULT_REPORT_LEN = 64;   
    let OUT_REPORT_LEN = DEFAULT_REPORT_LEN; 

    const PID_B003FUN = 0xB003;  
    const PID_MIN = 0xB000, PID_MAX = 0xB00F; 
    function isB003Fun(pid){ return pid === PID_B003FUN; }
    function isExpectedPid(pid){ return (pid >= PID_MIN && pid <= PID_MAX) || isB003Fun(pid); }

    let flashDevice = null;
    let inputReportDevice = null;
    let inQueue = [];
    let waiters = [];

    function hex(u8) {
      return Array.from(u8, b => b.toString(16).padStart(2,'0')).join(' ');
    }

    function addrBytes(addr) {
      return [(addr>>>16)&0xFF, (addr>>>8)&0xFF, addr&0xFF];
    }

    function isBoardDevice(hidDevice) {
      if (!hidDevice) return false;
      return hidDevice.vendorId === VENDOR_ID && (isExpectedPid(hidDevice.productId) || isB003Fun(hidDevice.productId));
    }

    async function findKnownBoardDevice() {
      if (!('hid' in navigator)) return null;
      const devices = await navigator.hid.getDevices();
      return devices.find(isBoardDevice) || null;
    }

    async function waitForBoardPresence({shouldBePresent, timeoutMs = 20000} = {}) {
      const current = await findKnownBoardDevice();
      if (shouldBePresent) {
        if (current) return current;
      } else {
        if (!current) return null;
      }

      return new Promise((resolve, reject) => {
        const eventName = shouldBePresent ? 'connect' : 'disconnect';
        let handlerRef = null;

        const cleanup = () => {
          clearTimeout(timer);
          if (handlerRef) {
            navigator.hid.removeEventListener(eventName, handlerRef);
            handlerRef = null;
          }
        };

        const timer = setTimeout(() => {
          cleanup();
          reject(new Error('timeout'));
        }, timeoutMs);

        handlerRef = (event) => {
          if (!isBoardDevice(event.device)) return;
          cleanup();
          if (shouldBePresent) {
            resolve(event.device);
          } else {
            resolve(null);
          }
        };

        navigator.hid.addEventListener(eventName, handlerRef);
      });
    }

    function onInputReport(e) {
      const u8 = new Uint8Array(e.data.buffer);
      if (OUT_REPORT_LEN === DEFAULT_REPORT_LEN && u8 && u8.length >= 8 && u8.length !== OUT_REPORT_LEN) {
        OUT_REPORT_LEN = u8.length;
        console.log('Detected report size: IN=' + u8.length + 'B ‚Üí OUT=' + OUT_REPORT_LEN + 'B');
      }
      if (waiters.length) {
        const {resolve} = waiters.shift();
        resolve(u8);
      } else {
        inQueue.push(u8);
      }
    }

    function detachInputReportListener() {
      if (inputReportDevice) {
        try {
          inputReportDevice.removeEventListener('inputreport', onInputReport);
        } catch (err) {
          console.warn('Failed to remove inputreport listener:', err);
        }
        inputReportDevice = null;
      }
    }

    function recv(timeoutMs=300) {
      return new Promise((resolve, reject) => {
        if (inQueue.length) {
          return resolve(inQueue.shift());
        }
        const timer = setTimeout(() => {
          const idx = waiters.findIndex(w => w.resolve === resolve);
          if (idx >= 0) waiters.splice(idx, 1);
          reject(new Error('timeout'));
        }, timeoutMs);
        waiters.push({
          resolve: (val)=>{ clearTimeout(timer); resolve(val); },
          reject
        });
      });
    }

    async function send(bytes, {expect=true, timeout=300}={}) {
      const raw = (bytes instanceof Uint8Array) ? bytes : new Uint8Array(bytes);
      const buf = new Uint8Array(OUT_REPORT_LEN);
      buf.fill(0);
      buf.set(raw.subarray(0, Math.min(raw.length, OUT_REPORT_LEN)));
      try {
        await flashDevice.sendReport(REPORT_ID, buf);
      } catch (e) {
        let hint = '';
        if (!flashDevice || !flashDevice.opened) hint = 'Device disconnected/closed.';
        else if (!isExpectedPid(flashDevice.productId) && !isB003Fun(flashDevice.productId)) hint = 'Incompatible PID.';
        else hint = 'Possible bootloader timeout.';
        throw new Error((e && e.message ? e.message : 'Failed to send report') + ' ‚Äî ' + hint);
      }
      if (!expect) return null;
      return await recv(timeout);
    }

    async function txrx(bytes, tries=3, timeout=300) {
      let lastErr = null;
      for (let i=0;i<tries;i++) {
        try {
          const resp = await send(bytes, {expect:true, timeout});
          return resp;
        } catch (e) {
          lastErr = e;
          await new Promise(r=>setTimeout(r, 50));
          try { await send([CMD.PING, 0x01,0,0,0,0,0,0], {expect:false}); } catch {}
        }
      }
      throw lastErr || new Error('txrx failure');
    }

    async function setupOpenedDevice(foundDevice, {showIntro=true}={}) {
      if (!foundDevice) return;

      detachInputReportListener();
      inQueue = [];
      waiters = [];

      flashDevice = foundDevice;
      if (!flashDevice.opened) {
        await flashDevice.open();
      }

      const productName = flashDevice.productName || 'ODB';
      if (showIntro) {
        updateStatus('Connected: ' + productName, 'connected');
        console.log('Connected: VID=0x' + flashDevice.vendorId.toString(16) + ' PID=0x' + flashDevice.productId.toString(16));
      }

      if (isB003Fun(flashDevice.productId)) {
        console.log('Detected B003Fun Bootloader (PID 0xB003). Using Feature Reports.');
        updateStatus('Connected (B003Fun)', 'connected');
        return;
      }

      if (!isExpectedPid(flashDevice.productId)) {
        console.log('WARNING: PID 0x' + flashDevice.productId.toString(16) + ' not supported.');
        updateStatus('Connected (incompatible)', 'error');
        throw new Error('Incompatible PID. Use the correct bootloader (PID 0xB003 or 0xB000‚Äì0xB00F).');
      }

      OUT_REPORT_LEN = DEFAULT_REPORT_LEN;
      flashDevice.addEventListener('inputreport', onInputReport);
      inputReportDevice = flashDevice;

      console.log('Using initial OUT report len = ' + OUT_REPORT_LEN + 'B (auto-adjusts on first input).');

      const pong = await txrx([CMD.PING, 0x01,0,0,0,0,0,0]).catch(()=>null);
      if (pong) console.log('PING ok (' + hex(pong) + ')');

      const info = await txrx([CMD.INFO, 0,0,0,0,0,0,0]).catch(()=>null);
      if (info) console.log('INFO: ' + hex(info));
    }

    async function ensureBootloaderReady() {
      if (!('hid' in navigator)) {
        throw new Error('This browser does not support WebHID. Use a recent Chrome/Edge.');
      }

      const permitted = await findKnownBoardDevice();
      if (!permitted) {
        throw new Error('Device is not paired. Pair the device first.');
      }

      if (flashDevice && flashDevice.opened) {
        detachInputReportListener();
        try { await flashDevice.close(); } catch (err) { console.warn('Failed to close current device:', err); }
      }
      flashDevice = null;

      updateStatus('Disconnect the One Dollar Board now to enter bootloader mode.', '');
      console.log('üîå Disconnect the One Dollar Board now to enter bootloader mode.');

      await waitForBoardPresence({shouldBePresent:false, timeoutMs:20000}).catch(() => {
        throw new Error('Timeout waiting for you to disconnect the One Dollar Board.');
      });

      updateStatus('Connect the One Dollar Board in bootloader mode...', '');
      console.log('‚ö° Now connect the One Dollar Board in bootloader mode...');

      const board = await waitForBoardPresence({shouldBePresent:true, timeoutMs:20000}).catch(() => {
        throw new Error('Timeout waiting for the One Dollar Board to reconnect.');
      });

      await setupOpenedDevice(board, {showIntro:true});
      console.log('‚úÖ Bootloader detected. Starting flash...');
    }

    function pagePad64(srcU8, offset) {
      const page = new Uint8Array(64).fill(0xFF);
      const len = Math.min(64, srcU8.length - offset);
      if (len > 0) page.set(srcU8.subarray(offset, offset + len));
      return page;
    }

    
    const word_wise_write_blob = new Uint8Array([
      0x23,0xa0,0x05,0x00,0x13,0x07,0x45,0x03,0x0c,0x43,0x50,0x43,0x2e,0x96,0x21,0x07,
      0x14,0x43,0x94,0xc1,0x91,0x05,0x11,0x07,0xe3,0xcc,0xc5,0xfe,0x93,0x06,0xf0,0xff,
      0x14,0xc1,0x82,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ]);
    const word_wise_read_blob = new Uint8Array([
      0x23,0xa0,0x05,0x00,0x13,0x07,0x45,0x03,0x0c,0x43,0x50,0x43,0x2e,0x96,0x21,0x07,
      0x94,0x41,0x14,0xc3,0x91,0x05,0x11,0x07,0xe3,0xcc,0xc5,0xfe,0x93,0x06,0xf0,0xff,
      0x14,0xc1,0x82,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    ]);
    const write64_flash = new Uint8Array([
      0x13,0x07,0x45,0x03,0x0c,0x43,0x13,0x86,0x05,0x04,0x5c,0x43,0x8c,0xc7,0x14,0x47,
      0x94,0xc1,0xb7,0x06,0x05,0x00,0xd4,0xc3,0x94,0x41,0x91,0x05,0x11,0x07,0xe3,0xc8,
      0xc5,0xfe,0xc1,0x66,0x93,0x86,0x06,0x04,0xd4,0xc3,0xfd,0x56,0x14,0xc1,0x82,0x80
    ]);

    function resetOp(){ const buffer=new Uint8Array(128); buffer.fill(0); buffer[0]=0xaa; return { buffer, commandplace:4 }; }
    function writeOp4(op, v){ const dv=new DataView(op.buffer.buffer); dv.setUint32(op.commandplace, v, true); op.commandplace+=4; }
    function writeOpArb(op, data){ op.buffer.set(data, op.commandplace); op.commandplace+=data.length; }

    async function commitOpFeature(op, {noGetReport=false}={}){
      const dv=new DataView(op.buffer.buffer);
      dv.setUint32(124, 0x1234abcd, true);
      op.buffer[0]=0xaa;
      await flashDevice.sendFeatureReport(0xaa, op.buffer.subarray(1));
      if (noGetReport) return null;
      for (let t=0;t<60;t++){
        await new Promise(r=>setTimeout(r, t?10:20));
        try {
          const view = await flashDevice.receiveFeatureReport(0xaa);
          const raw = new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
          const statusByte = raw.length ? raw[0] : 0;
          if (statusByte === 0xff) {
            const normalized = new Uint8Array(128);
            normalized.fill(0);
            normalized[0] = 0xaa;
            const copyLen = Math.min(127, raw.length);
            if (copyLen > 0) normalized.set(raw.subarray(0, copyLen), 1);
            return normalized;
          }
        } catch (err){
          if (t === 0) console.log('Failed to read feature report: '+(err?.message||err));
        }
      }
      throw new Error('Timeout waiting for bootloader response (feature report)');
    }

    async function readWordFeature(addr){
      const op=resetOp(); writeOpArb(op, word_wise_read_blob); writeOp4(op, addr); writeOp4(op, 4);
      const resp = await commitOpFeature(op);
      if (!resp || resp.length<64) return 0;
      const dv=new DataView(resp.buffer, (resp.byteOffset||0)+60, 4);
      return dv.getUint32(0, true);
    }
    async function writeWordFeature(addr, val){
      const op=resetOp(); writeOpArb(op, word_wise_write_blob); writeOp4(op, addr); writeOp4(op, 4);
      new DataView(op.buffer.buffer).setUint32(60, val, true);
      await commitOpFeature(op);
    }

    let flashUnlocked=false;
    async function unlockFlashFeature(){
      if (flashUnlocked) return true;
      const ctlr = await readWordFeature(0x40022010);
      if (ctlr & 0x8080){
        await writeWordFeature(0x40022004, 0x45670123);
        await writeWordFeature(0x40022004, 0xCDEF89AB);
        await writeWordFeature(0x40022008, 0x45670123);
        await writeWordFeature(0x40022008, 0xCDEF89AB);
        await writeWordFeature(0x40022024, 0x45670123);
        await writeWordFeature(0x40022024, 0xCDEF89AB);
        const ctlrAfter = await readWordFeature(0x40022010);
        if (ctlrAfter & 0x8080) throw new Error('Flash locked');
      }
      flashUnlocked=true; return true;
    }
    async function isSectorErasedFeature(address){
      const first = await readWordFeature(address & (~0x3f));
      return first === 0xFFFFFFFF;
    }
    async function eraseSectorFeature(address){
      await unlockFlashFeature();
      const CR_PAGE_ER=0x00020000, CR_STRT_Set=0x00000040;
      await writeWordFeature(0x40022010, CR_PAGE_ER);
      await writeWordFeature(0x40022014, address);
      await writeWordFeature(0x40022010, CR_STRT_Set | CR_PAGE_ER);
      await new Promise(r=>setTimeout(r,50));
      await writeWordFeature(0x40022010, 0);
    }
    async function blockWrite64Feature(address, data){
      if (data.length!==64) throw new Error('block must be 64 bytes');
      await unlockFlashFeature();
      if (!await isSectorErasedFeature(address)) await eraseSectorFeature(address);
      const CR_PAGE_PG=0x00010000, CR_BUF_RST=0x00080000;
      await writeWordFeature(0x40022010, CR_PAGE_PG);
      await writeWordFeature(0x40022010, CR_PAGE_PG|CR_BUF_RST);
      const op=resetOp();
      writeOpArb(op, write64_flash);
      writeOp4(op, address);
      writeOp4(op, 0x4002200c);
      op.buffer.set(data, 60);
      await commitOpFeature(op);
      await new Promise(r=>setTimeout(r,10));
    }
    function isAddressFlash(a){ return (a & 0xff000000) === 0x08000000; }
    async function writeBinaryBlobFeature(startAddress, dataU8){
      let address=startAddress; let offset=0; const data = dataU8;
      if (isAddressFlash(address)){
        let currentAddress = address & (~0x3f);
        if (currentAddress < address){
          const pre = address - currentAddress;
          const temp = new Uint8Array(64).fill(0xFF);
          temp.set(data.slice(0, Math.min(64-pre, data.length)), pre);
          await blockWrite64Feature(currentAddress, temp);
          offset = 64 - pre; currentAddress += 64;
          updateStatus('Flashing‚Ä¶ ' + Math.min(100, Math.round((offset/data.length)*100)) + '%', '');
        }
        while ((data.length - offset) >= 64){
          const blk = data.slice(offset, offset+64);
          await blockWrite64Feature(currentAddress, blk);
          offset += 64; currentAddress += 64;
          const pct = Math.round((offset/data.length)*100);
          updateStatus('Flashing‚Ä¶ ' + pct + '%', '');
        }
        if (offset < data.length){
          const temp = new Uint8Array(64).fill(0xFF);
          temp.set(data.slice(offset), 0);
          await blockWrite64Feature(currentAddress, temp);
          offset = data.length;
          updateStatus('Flashing‚Ä¶ 100%', '');
        }
        return;
      }
    }
    async function flashBinB003Fun(binU8){
      try {
        console.log('B003Fun compatible mode: using Feature Reports (0xaa, 128B).');
        flashUnlocked = false;
        const FLASH_BASE=0x08000000;
        await writeBinaryBlobFeature(FLASH_BASE, binU8);
        console.log('Flash completed successfully (B003Fun).');
        updateStatus('Flash completed successfully! Disconnect and reconnect to run the code.', 'connected');
      } catch (e) {
        console.error('B003Fun flash error: ' + e.message);
        updateStatus('Flash failed', 'error');
        throw e;
      }
    }

    async function flashBinWebHID(binU8) {
      const totalPages = Math.ceil(binU8.length / 64);      let addr = 0, pageIdx = 0;

      for (pageIdx = 0; pageIdx < totalPages; pageIdx++, addr += 64) {
        const page = pagePad64(binU8, addr);
        const [a2,a1,a0] = addrBytes(addr);

        await txrx([CMD.ERASE64, 0, a2,a1,a0, 0,0,0]).catch(e=>{
          throw new Error('ERASE64 failed at 0x'+addr.toString(16)+': '+e.message);
        });

        for (let i=0;i<16;i++){
          const b0 = page[i*4+0], b1 = page[i*4+1], b2 = page[i*4+2], b3 = page[i*4+3];
          await txrx([CMD.LOAD64,  i & 0x7F, a2,a1,a0, i & 0x7F, b0, b1]).catch(e=>{
            throw new Error('LOAD64/lo failed idx '+i+' @0x'+addr.toString(16)+': '+e.message);
          });
          await txrx([CMD.LOAD64, (i | 0x80) & 0xFF, a2,a1,a0, i & 0x7F, b2, b3]).catch(e=>{
            throw new Error('LOAD64/hi failed idx '+i+' @0x'+addr.toString(16)+': '+e.message);
          });
        }

        await txrx([CMD.PROG64, 0, a2,a1,a0, 0,0,0], 3, 600).catch(e=>{
          throw new Error('PROG64 failed at 0x'+addr.toString(16)+': '+e.message);
        });

        const pct = Math.round(((pageIdx+1)/totalPages)*100);
        updateStatus('Flashing‚Ä¶ ' + pct + '%', '');
      }

      console.log('Flash completed successfully!');
      updateStatus('Flash completed successfully! Disconnect and reconnect to run the code.', 'connected');
    }

    
    async function flashBinary(binaryBase64, size = null) {
      try {
        btnFlash.disabled = true;
        updateStatus('Preparing flash...', '');

        
        if (!('hid' in navigator)) {
          throw new Error('This browser does not support WebHID. Use a recent Chrome/Edge.');
        }

        
        const permitted = await findKnownBoardDevice();
        if (!permitted) {
          updateStatus('Pairing device...', '');
          console.log('No device paired. Requesting pairing...');
          
          
          await connectWebHID();
          
          console.log('‚úÖ Device paired successfully!');
        }

        
        const byteCharacters = atob(binaryBase64);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
          byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const binU8 = new Uint8Array(byteNumbers);

        console.log(`Starting flash: ${binU8.length} bytes`);

        await ensureBootloaderReady();

        if (isB003Fun(flashDevice.productId)) {
          await flashBinB003Fun(binU8);
        } else {
          await flashBinWebHID(binU8);
        }

        console.log(`‚úÖ Flash completed: ${binU8.length} bytes`);
        updateStatus('Flash completed successfully! Disconnect and reconnect to run the code.', 'connected');
      } catch (error) {
        console.error('‚ùå Error flashing:', error);
        updateStatus('‚ùå Flash error: ' + (error.message || 'Unknown'), 'error');
        throw error;
      } finally {
        btnFlash.disabled = false;
      }
    }

    async function connectWebHID() {
      if (!('hid' in navigator)) {
        throw new Error('This browser does not support WebHID. Use a recent Chrome/Edge.');
      }
      try {
        const devices = await navigator.hid.requestDevice({ filters: [{ vendorId: VENDOR_ID }] });
        if (!devices || !devices.length) {
          throw new Error('No device selected. Please select the One Dollar Board.');
        }
        await setupOpenedDevice(devices[0], {showIntro:true});
        updateStatus('Device connected. Ready to flash.', 'connected');
        console.log('‚úÖ Device paired successfully');
      } catch (error) {
        console.error('Error connecting:', error);
        updateStatus('Connection error: ' + (error.message || 'Unknown'), 'error');
        throw error; 
      }
    }

    
    async function tryReconnect() {
      if (isReconnecting || isConnected) {
        return;
      }

      isReconnecting = true;
      updateStatus('Connecting...', '');
      console.log('üîÑ Trying to reconnect automatically...');
      
      const connected = await checkConnection();
      isConnected = connected;
      
      if (connected) {
        console.log('‚úÖ Reconnected successfully');
        updateStatus('', 'connected'); 
      } else {
        console.log('‚ùå Reconnection failed, will try again...');
      }
      
      isReconnecting = false;
      return connected;
    }

    function updateStatus(text, className = '') {
      
      
      const hideMessages = ['Connected to Firebase', 'Synced', 'Connected', 'Editor ready - Sync active'];
      const showMessages = ['Connecting...', 'Compiling...', 'Compilation', 'Connect to Internet', 'OFFLINE'];
      const shouldShow = showMessages.some(msg => text.includes(msg));
      const shouldHide = className === 'connected' && hideMessages.some(msg => text.includes(msg)) && !shouldShow;
      
      if (shouldHide) {
        status.textContent = '';
        status.className = '';
      } else {
        status.textContent = text;
        status.className = className ? `status-${className}` : '';
      }
      
      
      if (text.includes('Connecting...')) {
        connectionIcon.className = 'disconnected';
        connectionIconSymbol.textContent = 'üü°';
        connectionTooltip.textContent = 'Connecting...';
      } else if (className === 'connected' || text.includes('Connected') || text.includes('Synced')) {
        connectionIcon.className = 'connected';
        connectionIconSymbol.textContent = 'üü¢';
        connectionTooltip.textContent = 'Connected';
      } else if (className === 'error' || text.includes('Error') || text.includes('‚ö†Ô∏è') || text.includes('Disconnected') || text.includes('OFFLINE') || text.includes('Connect to Internet')) {
        connectionIcon.className = 'disconnected';
        connectionIconSymbol.textContent = 'üî¥';
        connectionTooltip.textContent = 'Offline';
      } else {
        connectionIcon.className = 'disconnected';
        connectionIconSymbol.textContent = '‚ö™';
        connectionTooltip.textContent = 'Offline';
      }
    }

    function updateSyncIndicator(state) {
      syncIndicator.className = '';
      if (state === 'syncing') {
        syncIndicator.textContent = '‚è≥ Syncing...';
        syncIndicator.classList.add('sync-indicator-syncing');
      } else if (state === 'synced') {
        syncIndicator.textContent = '‚úì Synced';
        syncIndicator.classList.add('sync-indicator-synced');
        setTimeout(() => {
          syncIndicator.textContent = '‚óè';
          syncIndicator.className = '';
        }, 2000);
      } else {
        syncIndicator.textContent = '‚óè';
      }
    }

    // Create Firebase reference for project code (if not already created)
    if (database && currentProjectCode && !codeRef) {
      codeRef = ref(database, `${DATABASE_PATH}/code`);
    }

    
    async function checkConnection() {
      try {
        
        const testData = { 
          timestamp: Date.now(), 
          test: true,
          message: 'Connection test'
        };
        
        
        const writeResponse = await fetch(`${DATABASE_URL}${DATABASE_PATH}/test.json`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(testData)
        });
        
        if (!writeResponse.ok) {
          throw new Error(`HTTP ${writeResponse.status}: ${writeResponse.statusText}`);
        }
        
        
        const readResponse = await fetch(`${DATABASE_URL}${DATABASE_PATH}/test.json`);
        if (!readResponse.ok) {
          throw new Error(`HTTP ${readResponse.status}: ${readResponse.statusText}`);
        }
        
        const data = await readResponse.json();
        
        if (data && data.test === true) {
          updateStatus('‚úÖ Connected to Firebase', 'connected');
          console.log('‚úÖ Connection test successful (Fetch API)');
          isConnected = true;
          return true;
        } else {
          throw new Error('Invalid Firebase response');
        }
      } catch (error) {
        console.error('‚ùå Connection error:', error);
        
        
        updateStatus('OFFLINE', 'error');
        isConnected = false;
        return false;
      }
    }

    
    async function saveToFirebase(content) {
      if (isSyncing || content === lastSavedContent) {
        return; 
      }

      try {
        isSyncing = true;
        updateSyncIndicator('syncing');
        
        
        lastSavedContent = content;
        
        
        let currentData = {};
        try {
          const currentResponse = await fetch(`${DATABASE_URL}${DATABASE_PATH}/code.json`);
          if (currentResponse.ok) {
            currentData = await currentResponse.json() || {};
          }
        } catch (e) {
          
          console.warn('‚ö†Ô∏è Could not read current data from Firebase:', e);
        }
        
        
        
        const contentMatchesCompiled = currentData.content === content;
        const shouldPreserveCompilation = contentMatchesCompiled && 
                                         currentData.compilationStatus === 'success' && 
                                         currentData.binaryHash;
        
        
        const data = {
          content: content,
          language: 'javascript',
          lastModified: new Date().toISOString(),
          timestamp: Date.now(),
          size: content.length,
          
          ...(shouldPreserveCompilation && {
            compilationStatus: currentData.compilationStatus,
            binaryHash: currentData.binaryHash,
            binarySize: currentData.binarySize,
            compilationResult: currentData.compilationResult,
            compilationUpdatedAt: currentData.compilationUpdatedAt,
            binarySavedAt: currentData.binarySavedAt
          })
          
        };
        
        const response = await fetch(`${DATABASE_URL}${DATABASE_PATH}/code.json`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();
        
        updateSyncIndicator('synced');
        updateStatus('Synced', 'connected');
        console.log('‚úÖ Code saved to Firebase (Fetch API)');
      } catch (error) {
        console.error('‚ùå Error saving:', error);
        
        if (editor) {
          lastSavedContent = editor.getValue();
        }
        
        const errorMsgLower = (error.message || '').toLowerCase();
        if (errorMsgLower.includes('failed to fetch') || 
            errorMsgLower.includes('networkerror') ||
            errorMsgLower.includes('network request failed') ||
            errorMsgLower.includes('fetch')) {
          updateStatus('Connect to Internet', 'error');
          isConnected = false;
          
          setTimeout(() => {
            if (!isConnected) {
              tryReconnect();
            }
          }, 2000);
        } else {
          updateStatus('‚ùå Sync error: ' + (error.message || 'Unknown'), 'error');
        }
        updateSyncIndicator('error');
      } finally {
        
        setTimeout(() => {
          isSyncing = false;
        }, 100);
      }
    }

    
    function cleanCodeForHash(code) {
      return code
        .replace(/\/\/.*$/gm, "")
        .replace(/\/\*[\s\S]*?\*\//g, "")
        .replace(/\s+/g, " ")
        .trim();
    }

    async function getCodeHash(code) {
      const cleaned = cleanCodeForHash(code);
      const buffer = new TextEncoder().encode(cleaned);
      const hashBuffer = await crypto.subtle.digest("SHA-1", buffer);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, "0")).join("");
    }

    
    async function compileCode() {
      if (!editor) {
        updateStatus('‚ùå Editor not ready', 'error');
        return;
      }

      const content = editor.getValue();
      if (!content.trim()) {
        updateStatus('‚ö†Ô∏è No code to compile', 'error');
        return;
      }

      try {
        btnCompile.disabled = true;
        updateStatus('üî® Compiling...', '');

        
        const binaryHash = await getCodeHash(content);

        
        const data = {
          content: content,
          binaryHash: binaryHash,
          language: 'javascript',
          lastModified: new Date().toISOString(),
          timestamp: Date.now(),
          size: content.length,
          compilationStatus: 'pending',
          compilationRequested: true,
          compilationRequestedAt: new Date().toISOString()
        };

        const response = await fetch(`${DATABASE_URL}${DATABASE_PATH}/code.json`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });

        
        console.log('üß© Saved binaryHash before compile:', binaryHash);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        updateStatus('‚úÖ Compilation requested', 'connected');
        console.log('‚úÖ Compilation request sent to Firebase');

        
        setTimeout(() => {
          btnCompile.disabled = false;
          updateStatus('Synced', 'connected');
        }, 1000);
      } catch (error) {
        console.error('‚ùå Compilation error:', error);
        updateStatus('‚ùå Compilation error: ' + (error.message || 'Unknown'), 'error');
        btnCompile.disabled = false;
      }
    }

    require.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs' } });
    require(['vs/editor/editor.main'], async function () {
      
      let initialCode = 
`int main()
{
	SystemInit(); // 
	
	Delay_Ms(100);
	
	// Enable clocks for all GPIOs
	RCC->APB2PCENR |= RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOA;
	
	// Configure PD6 as output (main LED)
	GPIOD->CFGLR &= ~(0xF << (4 * 6));
	GPIOD->CFGLR |= (GPIO_Speed_50MHz | GPIO_CNF_OUT_PP) << (4 * 6);
	
	// Configure PC0 as output as well (test)
	GPIOC->CFGLR &= ~(0xF << (4 * 0));
	GPIOC->CFGLR |= (GPIO_Speed_50MHz | GPIO_CNF_OUT_PP) << (4 * 0);
	
	// Main loop - test both pins
	while(1) {
		// Turn ON PD6 and PC0
		GPIOD->BSHR = 1 << 6;
		GPIOC->BSHR = 1 << 0;
		Delay_Ms(1000);
		
		// Turn OFF PD6 and PC0
		GPIOD->BSHR = 1 << (6 + 16);
		GPIOC->BSHR = 1 << (0 + 16);
		Delay_Ms(1000);
	}
}
`;
      let initialData = null;
      try {
        const response = await fetch(`${DATABASE_URL}${DATABASE_PATH}/code.json`);
        if (response.ok) {
          const data = await response.json();
          initialData = data;
          if (data && data.content) {
            initialCode = data.content;
            lastSavedContent = initialCode;
            console.log('‚úÖ Code loaded from Firebase (Fetch API)');
            
            
            if (data.compilationStatus === 'success' && data.binaryHash) {
              console.log('üîç Compiled binaryHash found on page load');
              console.log('   - binaryHash:', data.binaryHash);
              console.log('   - binarySize:', data.binarySize);
            }
          }
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Error loading initial code:', error);
        
      }

      editor = monaco.editor.create(document.getElementById('editor'), {
        value: initialCode,
        language: 'javascript',
        theme: 'vs-dark',
        automaticLayout: true,
        fontSize: 14,
        minimap: { enabled: true },
        scrollBeyondLastLine: false,
        wordWrap: 'on'
      });

      
      await loadProjectName();
      
      
      const projectNameDisplay = document.getElementById('projectNameDisplay');
      const projectNameInput = document.getElementById('projectNameInput');
      
      if (projectNameDisplay) {
        
        projectNameDisplay.addEventListener('dblclick', (e) => {
          e.preventDefault();
          enterEditMode();
        });
      }
      
      if (projectNameInput) {
        
        projectNameInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            exitEditMode(true);
          } else if (e.key === 'Escape') {
            e.preventDefault();
            exitEditMode(false);
          }
        });
        
        
        projectNameInput.addEventListener('blur', () => {
          exitEditMode(true);
        });
      }

      
      const connected = await checkConnectionWithFlag();
      if (connected) {
        updateStatus('Editor ready - Sync active', 'connected');
        updateSyncIndicator('synced');
        btnCompile.disabled = false;
        
        
        if (initialData && initialData.compilationStatus === 'success' && initialData.binaryHash) {
          const currentContent = editor.getValue();
          const firebaseContent = initialData.content || '';
          
          
          const isValidBinary = await isBinaryValidForCode(initialData, currentContent, firebaseContent);
          
          if (isValidBinary) {
            
            const cacheData = await fetchBinaryFromCache(initialData.binaryHash);
            
            if (cacheData && cacheData.binary) {
              const size = cacheData.binarySize || initialData.binarySize || 0;
              showFlashButton(cacheData.binary, size);
              console.log('‚úÖ Flash button shown on page load (valid binary from cache)');
              console.log('   - binaryHash:', initialData.binaryHash);
              console.log('   - binarySize:', size, 'bytes');
            } else {
              console.log('‚ö†Ô∏è binaryHash found but binary not found in cache');
              hideFlashButton();
            }
          } else {
            console.log('‚ö†Ô∏è BinaryHash found but not valid for current code');
            hideFlashButton();
          }
        }
      } else {
        updateStatus('Editor ready - Waiting for connection...', '');
        updateSyncIndicator('');
      }

      
      editor.onDidChangeModelContent(() => {
        const currentContent = editor.getValue();
        
        
        if (!isLocalChange && currentContent !== lastSavedContent) {
          hideFlashButton();
        }
        
        
        if (!isLocalChange) {
          
          if (saveTimeout) {
            clearTimeout(saveTimeout);
          }

          
          saveTimeout = setTimeout(() => {
            saveToFirebase(currentContent);
          }, DEBOUNCE_DELAY);
        }
      });

      
      btnCompile.addEventListener('click', () => {
        (async () => {
          const code = editor.getValue();
          const hash = await getCodeHash(code);
          try {
            const cachedResponse = await fetch(`${DATABASE_URL}/cache/${hash}.json`);
            if (cachedResponse.ok) {
              const cached = await cachedResponse.json();
              if (cached && cached.binary) {
                console.log('‚ö° Binary loaded from cache:', hash);
                updateStatus('‚ö° Loaded from cache', 'connected');
                
                
                try {
                  const currentDataResponse = await fetch(`${DATABASE_URL}${DATABASE_PATH}/code.json`);
                  const currentData = currentDataResponse.ok ? await currentDataResponse.json() : {};
                  
                  const updateData = {
                    ...currentData,
                    content: code,
                    binaryHash: hash,
                    binarySize: cached.binarySize || 0,
                    compilationStatus: 'success',
                    compilationUpdatedAt: new Date().toISOString(),
                    binarySavedAt: new Date().toISOString(),
                    timestamp: Date.now(),
                    lastModified: new Date().toISOString()
                  };
                  
                  const updateResponse = await fetch(`${DATABASE_URL}${DATABASE_PATH}/code.json`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updateData)
                  });
                  
                  if (updateResponse.ok) {
                    console.log('‚úÖ Firebase updated with success status from cache');
                    console.log('   - binaryHash:', hash);
                    console.log('   - binarySize:', cached.binarySize || 0);
                    
                    
                    
                    setTimeout(() => {
                      showFlashButton(cached.binary, cached.binarySize || 0);
                      console.log('‚úÖ Flash button shown after Firebase update');
                    }, 100);
                  } else {
                    console.warn('‚ö†Ô∏è Failed to update Firebase:', updateResponse.status, updateResponse.statusText);
                    
                    showFlashButton(cached.binary, cached.binarySize || 0);
                  }
                } catch (updateError) {
                  console.warn('‚ö†Ô∏è Failed to update Firebase:', updateError);
                  
                  showFlashButton(cached.binary, cached.binarySize || 0);
                }
                
                return;
              }
            }
          } catch (e) {
            console.warn('‚ö†Ô∏è Cache lookup failed:', e);
          }
          compileCode();
        })();
      });

      
      
      if (codeRef) {
        console.log('‚úÖ Configuring Firebase listener');
        console.log('   - codeRef exists:', !!codeRef);
        console.log('   - database exists:', !!database);
        
        try {
          console.log('üîÑ Calling onValue...');
          onValue(codeRef, async (snapshot) => {
            console.log('üî•üî•üî• [LISTENER TRIGGERED] Event received from Firebase!');
            console.log('   - snapshot.exists():', snapshot.exists());
            if (!snapshot.exists()) {
              console.log('   - Snapshot does not exist, returning');
              return;
            }

            const data = snapshot.val();
            if (!data || !data.content) {
              return;
            }

            const currentContent = editor.getValue();
            const firebaseContent = data.content;

            
            console.log('üì° [LISTENER] Data received from Firebase:');
            console.log('   - compilationStatus:', data.compilationStatus);
            console.log('   - binaryHash:', data.binaryHash);
            console.log('   - binarySize:', data.binarySize);
            console.log('   - isSyncing:', isSyncing);
            console.log('   - firebaseContent === lastSavedContent:', firebaseContent === lastSavedContent);

            
            
            if (data.compilationStatus === 'success') {
              
              
              
              if (!data.binaryHash) {
                hideFlashButton();
                updateStatus('‚úÖ Compilation completed (no binaryHash)', 'connected');
                btnCompile.disabled = false;
                console.log('‚ö†Ô∏è Status is success but binaryHash does not exist - button hidden');
                
              } else {
                
                const cacheData = await fetchBinaryFromCache(data.binaryHash);
                
                if (!cacheData || !cacheData.binary) {
                  hideFlashButton();
                  updateStatus('‚úÖ Compilation completed (binary not found in cache)', 'connected');
                  btnCompile.disabled = false;
                  console.log('‚ö†Ô∏è binaryHash exists but binary not found in cache');
                  return;
                }
                
                
                const isValidBinary = await isBinaryValidForCode(data, currentContent, firebaseContent);
                
                
                console.log('üîç [SUCCESS] Data received from Firebase:');
                console.log('   - compilationStatus:', data.compilationStatus);
                console.log('   - binaryHash:', data.binaryHash);
                console.log('   - binarySize:', cacheData.binarySize || data.binarySize);
                console.log('   - binarySavedAt:', data.binarySavedAt);
                console.log('   - code timestamp:', data.timestamp || data.lastModified);
                console.log('   - isValidBinary:', isValidBinary);
                
                if (isValidBinary) {
                  
                  const size = cacheData.binarySize || data.binarySize || 0;
                  showFlashButton(cacheData.binary, size);
                  updateStatus(`‚úÖ Compilation successful! (${size} bytes)`, 'connected');
                  btnCompile.disabled = false;
                  console.log('‚úÖ‚úÖ‚úÖ Flash button SHOWN!');
                  console.log('   - Binary valid for current code');
                } else {
                  hideFlashButton();
                  console.log('‚ö†Ô∏è Button hidden: binary is not valid for current code');
                  if (currentContent !== firebaseContent) {
                    console.log('   - Reason: editor code does not match compiled code');
                    console.log('   - Difference:', Math.abs(currentContent.length - firebaseContent.length), 'chars');
                  } else {
                    console.log('   - Reason: binary was compiled before last code modification');
                    console.log('   - binarySavedAt:', data.binarySavedAt);
                    console.log('   - code timestamp:', data.timestamp || data.lastModified);
                  }
                }
              }
            } else if (data.compilationStatus === 'error') {
              const errorMsg = data.compilationError || 'Unknown error';
              updateStatus(`‚ùå Compilation error: ${errorMsg}`, 'error');
              btnCompile.disabled = false;
              hideFlashButton();
            } else if (data.compilationStatus === 'pending') {
              updateStatus('üî® Compiling...', '');
              btnCompile.disabled = true;
              hideFlashButton();
            } else {
              
              
              if (!data.binaryHash || !data.compilationStatus) {
                hideFlashButton();
                console.log('‚ö†Ô∏è Button hidden: no compilation status or binaryHash removed');
              }
            }

            
            
            if (!data.binaryHash) {
              hideFlashButton();
              console.log('‚ö†Ô∏è Final check: binaryHash does not exist - button hidden');
            } else if (data.compilationStatus === 'success') {
              
              const isValidBinary = await isBinaryValidForCode(data, currentContent, firebaseContent);
              if (isValidBinary && btnFlash.style.display === 'none') {
                const cacheData = await fetchBinaryFromCache(data.binaryHash);
                if (cacheData && cacheData.binary) {
                  const size = cacheData.binarySize || data.binarySize || 0;
                  showFlashButton(cacheData.binary, size);
                  console.log('‚úÖ‚úÖ‚úÖ Flash button SHOWN in final check!');
                }
              }
            }

            
            
            
            if (isSyncing || firebaseContent === lastSavedContent) {
              
              
              return;
            }

            
            if (currentContent !== firebaseContent) {
              isLocalChange = true; 
              
              
              if (saveTimeout) {
                clearTimeout(saveTimeout);
                saveTimeout = null;
              }
              
              
              editor.setValue(firebaseContent);
              lastSavedContent = firebaseContent;
              
              
              
              const updatedContent = editor.getValue();
              const isValidBinary = data.compilationStatus === 'success' && 
                                   await isBinaryValidForCode(data, updatedContent, firebaseContent);
              
              if (isValidBinary && data.binaryHash) {
                
                const cacheData = await fetchBinaryFromCache(data.binaryHash);
                if (cacheData && cacheData.binary) {
                  const size = cacheData.binarySize || data.binarySize || 0;
                  showFlashButton(cacheData.binary, size);
                  console.log('‚úÖ Flash button kept after Firebase update (valid binary from cache)');
                } else {
                  hideFlashButton();
                  console.log('‚ö†Ô∏è binaryHash valid but binary not found in cache');
                }
              } else {
                
                hideFlashButton();
                console.log('‚ö†Ô∏è Button hidden: code was updated from Firebase and binary is not valid');
              }
              
              updateStatus('üîÑ Updated from Firebase', 'connected');
              updateSyncIndicator('synced');
              console.log('üîÑ Code updated from Firebase');
              
              
              setTimeout(() => {
                isLocalChange = false;
                updateStatus('Synced', 'connected');
              }, 200);
            }
          }, (error) => {
            console.error('‚ùå Erro no listener do Firebase:', error);
            console.warn('‚ö†Ô∏è Error in Firebase SDK listener, using polling:', error);
            
            startPolling();
          });
          console.log('‚úÖ Listener do Firebase configurado com sucesso! Aguardando mudan√ßas...');
          
          
          
          console.log('üîÑ Iniciando verifica√ß√£o peri√≥dica de fallback (a cada 2 segundos)...');
          setInterval(async () => {
            if (isSyncing) return;
            
            try {
              const response = await fetch(`${DATABASE_URL}${DATABASE_PATH}/code.json`);
              if (response.ok) {
                const data = await response.json();
                if (!data || !data.content) return;
                
                const currentContent = editor.getValue();
                const firebaseContent = data.content;
                
                
                if (data.compilationStatus === 'success' && data.binaryHash) {
                  
                  const cacheData = await fetchBinaryFromCache(data.binaryHash);
                  
                  if (cacheData && cacheData.binary) {
                    const isValidBinary = await isBinaryValidForCode(data, currentContent, firebaseContent);
                    if (isValidBinary && btnFlash.style.display === 'none') {
                      const size = cacheData.binarySize || data.binarySize || 0;
                      showFlashButton(cacheData.binary, size);
                      console.log('‚úÖ‚úÖ‚úÖ [FALLBACK] Flash button SHOWN by periodic check!');
                    } else if (!isValidBinary && btnFlash.style.display !== 'none') {
                      hideFlashButton();
                      console.log('‚ö†Ô∏è [FALLBACK] Button hidden by periodic check (invalid binary)');
                    }
                  } else {
                    if (btnFlash.style.display !== 'none') {
                      hideFlashButton();
                      console.log('‚ö†Ô∏è [FALLBACK] Button hidden by periodic check (binary not found in cache)');
                    }
                  }
                } else if (!data.binaryHash && btnFlash.style.display !== 'none') {
                  hideFlashButton();
                  console.log('‚ö†Ô∏è [FALLBACK] Button hidden by periodic check (no binaryHash)');
                }
              }
            } catch (error) {
              
            }
          }, 2000); 
          
        } catch (error) {
          console.error('‚ùå Error configuring listener:', error);
          console.warn('‚ö†Ô∏è SDK not available, using polling:', error);
          startPolling();
        }
      } else {
        
        console.log('‚ö†Ô∏è codeRef does not exist, using polling');
        startPolling();
      }

      
      function startPolling() {
        let lastTimestamp = Date.now();
        setInterval(async () => {
          if (isSyncing) return; 
          
          try {
            const response = await fetch(`${DATABASE_URL}${DATABASE_PATH}/code.json`);
            if (response.ok) {
              const data = await response.json();
              if (!data) return;
              
              const currentContent = editor.getValue();
              const firebaseContent = data.content;
              
              
              if (data.compilationStatus) {
                if (data.compilationStatus === 'success') {
                  
                  if (!data.binaryHash) {
                    hideFlashButton();
                    updateStatus('‚úÖ Compilation completed (no binaryHash)', 'connected');
                    btnCompile.disabled = false;
                    console.log('‚ö†Ô∏è [POLLING] Status is success but binaryHash does not exist - button hidden');
                  } else {
                    
                    const cacheData = await fetchBinaryFromCache(data.binaryHash);
                    
                    if (!cacheData || !cacheData.binary) {
                      hideFlashButton();
                      updateStatus('‚úÖ Compilation completed (binary not found in cache)', 'connected');
                      btnCompile.disabled = false;
                      console.log('‚ö†Ô∏è [POLLING] binaryHash exists but binary not found in cache');
                    } else {
                      
                      const size = cacheData.binarySize || data.binarySize || 0;
                      updateStatus(`‚úÖ Compilation successful! (${size} bytes)`, 'connected');
                      btnCompile.disabled = false;
                      
                      
                      const isValidBinary = await isBinaryValidForCode(data, currentContent, firebaseContent);
                      
                      
                      console.log('üîç [POLLING SUCCESS] Data received from Firebase:');
                      console.log('   - compilationStatus:', data.compilationStatus);
                      console.log('   - binaryHash:', data.binaryHash);
                      console.log('   - binarySize:', cacheData.binarySize || data.binarySize);
                      console.log('   - isValidBinary:', isValidBinary);
                      
                      if (isValidBinary) {
                        showFlashButton(cacheData.binary, size);
                        console.log('‚úÖ‚úÖ‚úÖ [POLLING] Flash button SHOWN!');
                        console.log('   - Binary valid for current code');
                      } else {
                        hideFlashButton();
                        console.log('‚ö†Ô∏è [POLLING] Button hidden: binary is not valid');
                      }
                    }
                  }
                } else if (data.compilationStatus === 'error') {
                  const errorMsg = data.compilationError || 'Erro desconhecido';
                  updateStatus(`‚ùå Erro na compila√ß√£o: ${errorMsg}`, 'error');
                  btnCompile.disabled = false;
                  hideFlashButton();
                } else if (data.compilationStatus === 'pending') {
                  updateStatus('üî® Compiling...', '');
                  btnCompile.disabled = true;
                  hideFlashButton();
                } else {
                  
                  if (!data.binaryHash || !data.compilationStatus) {
                    hideFlashButton();
                  }
                }
                
                
                if (!data.binaryHash) {
                  hideFlashButton();
                  console.log('‚ö†Ô∏è [POLLING] Final check: binaryHash does not exist - button hidden');
                }
              }
              
              
              if (data.content && data.timestamp > lastTimestamp) {
                if (currentContent !== firebaseContent && firebaseContent !== lastSavedContent) {
                  isLocalChange = true;
                  editor.setValue(firebaseContent);
                  lastSavedContent = firebaseContent;
                  lastTimestamp = data.timestamp;
                  
                  
                  const updatedContent = editor.getValue();
                  const isValidBinary = data.compilationStatus === 'success' && 
                                       await isBinaryValidForCode(data, updatedContent, firebaseContent);
                  
                  if (isValidBinary && data.binaryHash) {
                    
                    const cacheData = await fetchBinaryFromCache(data.binaryHash);
                    if (cacheData && cacheData.binary) {
                      const size = cacheData.binarySize || data.binarySize || 0;
                      showFlashButton(cacheData.binary, size);
                    } else {
                      hideFlashButton();
                    }
                  } else {
                    hideFlashButton();
                  }
                  
                  updateStatus('üîÑ Updated from Firebase', 'connected');
                  setTimeout(() => {
                    isLocalChange = false;
                    updateStatus('Synced', 'connected');
                  }, 200);
                }
              }
            }
          } catch (error) {
            
          }
        }, 2000); 
      }
    });

    
    function downloadBinary(binaryBase64, size = null) {
      try {
        
        const byteCharacters = atob(binaryBase64);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
          byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        const blob = new Blob([byteArray], { type: 'application/octet-stream' });
        
        
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'code.bin';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        console.log(`‚úÖ Download iniciado: code.bin (${size || byteArray.length} bytes)`);
        updateStatus(`üì• Download iniciado (${size || byteArray.length} bytes)`, 'connected');
        setTimeout(() => {
          updateStatus('Synced', 'connected');
        }, 2000);
      } catch (error) {
        console.error('‚ùå Erro ao fazer download:', error);
        updateStatus('‚ùå Erro ao fazer download', 'error');
      }
    }

    
    async function checkConnectionWithFlag() {
      const result = await checkConnection();
      isConnected = result;
      return result;
    }

    
    window.addEventListener('load', () => {
      
      setTimeout(async () => {
        await checkConnectionWithFlag();
      }, 1000);
      
      
      reconnectInterval = setInterval(async () => {
        if (!isConnected) {
          await tryReconnect();
        }
      }, 3000);
    });

  </script>
</body>
</html>

